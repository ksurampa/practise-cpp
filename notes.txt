https://learning.oreilly.com/library/view/c-primer-fifth

GCC github link: https://github.com/gcc-mirror/gcc

echo $? on UNIX
echo %ERRORLEVEL%% on Windows

g++ -o Hello HelloWorld.cpp node.cpp -Wall -std=c++0x		// C++ 11

iostream -> 1 istream and 3 ostream objects
	cin - istream
	cout - ostream
	cerr - ostream
	clog - ostream

>> & << are input and output operators
endl is manipulator also responsible for flushing the buffer to ostream along with ending the current line

Namespaces allow us to avoid inadvertant collisions between the names we define and uses of those same names inside library. All the name defined by the standard library are in the std namespace

:: -> scope operator

A block is a sequence of zero or more statments enclosed by curly braces

+= -> Compound Assignment operator

CTRL + d -> End of File in UNIX
CTRL + z -> End of File in Windows

./bookstore <infile >outfile

"."	->	Dot Operator
() 	->	Call Operator

Primitive Data types:
---------------------

	Characters, integers, boolean, floating point numbers etc.,
	and special type called void

	Arithmetic types are divided into 2 categories: integral types (which include character and boolean)
	and floating-point types

Type			Meaning					Size

bool			boolean					NA
char			character				8 bits
wchar_t			wide character				16 bits
char16_t		Unicode Character			16 bits
char32_t		Unicode Character			32 bits
short			Short integer				16 bits
int			integer					32 bits (min 16 bits)
long			long integer				64 bits (min 32 bits)
long long		long integer				64 bits
float			single-precision floating-point		6 significant digits (32 bits)
double			double-precision floating point		10 significant digits (64 bits)
long double		extended-precision floating point	10 significant digits (128 bits)

Literals:
---------

The type of string literal is array of constant char s

// multiline string literal
std::cout << "a really, really long string literal "
             "that spans two lines" << std::endl;

The language defines several escape sequences:

newline            \n     horizontal tab      \t     alert (bell)       \a
vertical tab       \v     backspace          \b     double quote  \"
backslash         \\     question mark     \?     single quote    \'
carriage return   \r     formfeed            \f

We can also write a generalized escape sequence, which is \x followed by one or more hexadecimal digits or a \ followed by one, two, or three octal digits. The value represents the numerical value of the character. Some examples (assuming the Latin-1 character set):

\7 (bell)    \12 (newline)      \40 (blank)
\0 (null)    \115 ('M')         \x4d ('M')

As with an escape sequence defined by the language, we use these escape sequences as we would any other character:

std::cout << "Hi \x4dO\115!\n";  // prints Hi MOM! followed by a newline
std::cout << '\115' << '\n';     // prints M followed by a newline

Specifying the type of a literal:

We can override the default type of an integer, floating- point, or character literal by supplying a suffix or prefix

L'a'     // wide character literal, type is wchar_t
u8"hi!"  // utf-8 string literal (utf-8 encodes a Unicode character in 8 bits)
42ULL    // unsigned integer literal, type is unsigned long long
1E-3F    // single-precision floating-point literal, type is float
3.14159L // extended-precision floating-point literal, type is long double

We can independently specify the signedness and size of an integral literal. If the suffix contains a U, then the literal has an unsigned type, so a decimal, octal, or hexadecimal literal with a U suffix has the smallest type of unsigned int, unsigned long, or unsigned long long in which the literal’s value fits. If the suffix contains an L, then the literal’s type will be at least long; if the suffix contains LL, then the literal’s type will be either long long or unsigned long long. We can combine U with either L or LL. For example, a literal with a suffix of UL will be either unsigned long or unsigned long long, depending on whether its value fits in unsigned long.

Variables:
----------

std::string book("0-201-78345-X"); // book initialized from string literal

An object is a region of memory that has a type. We will freely use the term object regardless of whether the object has built-in or class type, is named or unnamed, or can be read or written.

Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object’s current value and replaces that value with a new one.

List Initialization:
--------------------

we can use any of the following four different ways to define an int variable named units_sold and initialize it to 0:

int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);

The generalized use of curly braces for initialization was introduced as part of the new standard. This form of initialization previously had been allowed only in more restricted ways. For reasons we’ll learn about in § 3.3.1 (p. 98), this form of initialization is referred to as list initialization. Braced lists of initializers can now be used whenever we initialize an object and in some cases when we assign a new value to an object

In C++ 11, When used with variables of built-in type, this form of initialization has one important property: The compiler will not let us list initialize variables of built-in type if the initializer might lead to the loss of information:

long double ld = 3.1415926536;
int a{ld}, b = {ld}; // error: narrowing conversion required
int c(ld), d = ld;   // ok: but value will be truncated

Default Initialization: 
-----------------------

When we define a variable without an initializer, the variable is default initialized. Such variables are given the “default” value. What that default value is depends on the type of the variable and may also depend on where the variable is defined.

Variables defined outside any function body are initialized to 0. Variables of built-in type defined inside of a function are uninitialized

C++ is a statically typed language, which means that types are checked at compile time. The process by which types are checked is referred to as type checking.

C++ Keywords:
-------------

alignas		continue	friend		register		true
alignof		decltype	goto		reinterpret_cast	try
asm		default		if		return			typedef
auto		delete		inline		short			typeid
bool		do		int		signed			typename
break		double		long		sizeof			union
case		dynamic_cast	mutable		static			unsigned
catch		else		namespace	static_assert		using
char		enum		new		static_cast		virtual
char16_t	explicit	noexcept	struct			void
char32_t	export		nullptr		switch			volatile
class		extern		operator	template		wchar_t
const		false		private		this			while
constexpr	float		protected	thread_local
const_cast	for		public		throw

C++ Alternative Operator Names

and	bitand	compl	not_eq	or_eq	xor_eq
and_eq	bitor	not	or	xor

Identifiers must begin with either a letter or an underscore

Compound Types:
---------------

References:
-----------

References are of 2 types lvalue and rvalue. rvalue reference is introduced by C++ 11 as new kinda reference. rvalue references are primarily intended for use inside classes. A "reference" in general means "lvalue reference"

A reference defines an alternative name for an object. A reference type “refers to” another type. We define a reference type by writing a declarator of the form &d, where d is the name being declared:

int ival = 1024;
int &refVal = ival;  // refVal refers to (is another name for) ival
int &refVal2;        // error: a reference must be initialized

A reference is an alias. Address of both the var and reference var when printed shall be same.

Pointers:
---------

& - address of operator
* - dereference operator
nullptr - null pointer // Introduced in C++ 11

	int *p1 = nullptr; // equivalent to int *p1 = 0;
	int *p2 = 0;       // directly initializes p2 from the literal constant 0
	// must #include cstdlib
	int *p3 = NULL;    // equivalent to int *p3 = 0;

Modern C++ programs must not use NULL, instead use nullptr

As we’ve seen, a variable definition consists of a base type and a list of declarators. Each declarator can relate its variable to the base type differently from the other declarators in the same definition. Thus, a single definition might define variables of different types:

	// i is an int; p is a pointer to int; r is a reference to int
	int i = 1024, *p = &i, &r = i;

It is a common misconception to think that the type modifier (* or &) applies to all the variables defined in a single statement. Part of the problem arises because we can put whitespace between the type modifier and the name being declared:

	int* p;  // legal but might be misleading

In the above stmt, "int" is base type. "*" is type modifier "p" identifier. *p is declarator

Pointers to Pointers:
---------------------

In general, there are no limits to how many type modifiers can be applied to a declarator. When there is more than one modifier, they combine in ways that are logical but not always obvious. As one example, consider a pointer. A pointer is an object in memory, so like any object it has an address. Therefore, we can store the address of a pointer in another pointer.

We indicate each pointer level by its own *. That is, we write ** for a pointer to a pointer, *** for a pointer to a pointer to a pointer, and so on:

	int ival = 1024;
	int *pi = &ival;    // pi points to an int
	int **ppi = &pi;    // ppi points to a pointer to an int

Here pi is a pointer to an int and ppi is a pointer to a pointer to an in

Just as dereferencing a pointer to an int yields an int, dereferencing a pointer to a pointer yields a pointer. To access the underlying object, we must dereference the original pointer twice:

	cout << "The value of ival\n"
	     << "direct value: " << ival << "\n"
	     << "indirect value: " << *pi << "\n"
	     << "doubly indirect value: " << **ppi
	     << endl;

This program prints the value of ival three different ways: first, directly; then, through the pointer to int in pi; and finally, by dereferencing ppi twice to get to the underlying value in ival

References to Pointers:
-----------------------

A reference is not an object. Hence, we may not have a pointer to a reference. However, because a pointer is an object, we can define a reference to a pointer:

	int i = 42;
	int *p;        // p is a pointer to int
	int *&r = p;   // r is a reference to the pointer p
	r = &i; //  r refers to a pointer; assigning &i to r makes p point to i
	*r = 0; //  dereferencing r yields i, the object to which p points; changes i to 0

The easiest way to understand the type of r is to read the definition right to left. The symbol closest to the name of the variable (in this case the & in &r) is the one that has the most immediate effect on the variable’s type. Thus, we know that r is a reference. The rest of the declarator determines the type to which r refers. The next symbol, * in this case, says that the type r refers to is a pointer type. Finally, the base type of the declaration says that r is a reference to a pointer to an int.

Const:
------

we can’t change the value of a const object after we create it, it must be initialized. As usual, the initializer may be an arbitrarily complicated expression:

	const int i = get_size();  // ok: initialized at run time
	const int j = 42;          // ok: initialized at compile time
	const int k;               // error: k is uninitialized const


References/Further Reading:
---------------------------

https://learning.oreilly.com/playlists/3b5aa7fb-ecc1-4356-8586-9c3251f58aee
https://learning.oreilly.com/library/view/learning-object-oriented-programming/9781785289637/
https://learning.oreilly.com/library/view/head-first-design/9781492077992
https://en.cppreference.com/w/cpp/11
https://www.cplusplus.com/reference/
https://en.cppreference.com/w/
https://www.geeksforgeeks.org/c-plus-plus/?ref=shm
https://docs.microsoft.com/en-us/cpp/cpp/?view=msvc-170
https://www.javatpoint.com/cpp-tutorial

Boost Library:
--------------

https://www.boost.org/doc/libs/
https://theboostcpplibraries.com/
https://www.geeksforgeeks.org/advanced-c-boost-library/

Coding Practise Sites:
----------------------

codeforces
leetcode
codechef
atcoder

